//===--------------------- CGMTKUBSanTrapWarnFilter.cpp -------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// Filter warning of undefined behavior sanitizer traps (ubsantrap)
// that are guarded by a precondition of specific form:
// if (overflow-condition) {
//   ...
//   goto err;
// }
// <may overflow expression>
//
// The traps are generated by
//  -fsanitize-trap=all -fsanitize=unsigned-integer-overflow
//
// Supported preconditions:
//
// expression | precondition
// -----------+-------------
//  a + b     | max - a < b
//  a += b    |
// -----------+-------------
//  a - b     | a < b
//  a -= b    |
// -----------+-------------
//  a--       | a == 0
//  --a       |
// -----------+-------------
//  a++       | a == max
//  ++a       |
// -----------+-------------
//  a * b     | a && max/a < b
//  a *= b    |
//===----------------------------------------------------------------------===//

#include "CodeGenModule.h"
#include "clang/ASTMatchers/ASTMatchFinder.h"
#include "llvm/IR/IntrinsicInst.h"

static llvm::cl::opt<int>
    TrapWarningTrace("trace-warn-trap-visitor",
                     llvm::cl::desc("Enable Trap warning tracing"),
                     llvm::cl::init(0));

static llvm::cl::opt<bool> TrapWarningEmitInFE(
    "warn-trap-in-frontend",
    llvm::cl::desc("Enable Trap warning in intermediate step (front-end)"),
    llvm::cl::init(false));

using namespace clang;
using namespace CodeGen;
using namespace clang::ast_matchers;
using llvm::Value;

namespace {
using ExprInsPair = std::pair<const Expr *, Value *>;
using OverflowIter = SmallVector<ExprInsPair, 4>::const_iterator;

class UBSanTrapWarnFilter : public MatchFinder::MatchCallback {
protected:
  CodeGenModule *CGM = nullptr;
  void matchCondition(const Expr *Cond, const Stmt *GuardedStmt,
                      const MatchFinder::MatchResult &Result);
  uint64_t getExprTypeMax(const Expr *E, ASTContext &Context);
  uint64_t evalAllConstantsArithExpr(const Expr *E, ASTContext &Context,
                                     bool &Valid);
  void eliminateWarning(Value *OverflowLoc);
  void removeWarningFromList(const Expr *GuardedExpr);
  bool isBoundMax(const MatchFinder::MatchResult &Result);

public:
  UBSanTrapWarnFilter(CodeGenModule *CGM) : CGM(CGM) {}
  void run(const MatchFinder::MatchResult &Result) override {}
};

//===----------------------------------------------------------------------===//
// utility functions
//===----------------------------------------------------------------------===//
uint64_t UBSanTrapWarnFilter::getExprTypeMax(const Expr *E,
                                             ASTContext &Context) {
  if (E) {
    QualType exprType = E->getType();
    const Type *T = exprType.getTypePtr();
    if (T && (T->isUnsignedIntegerType() || T->isLiteralType(Context))) {
      switch (Context.getTypeInfo(T).Width) {
      case 32:
        return std::numeric_limits<uint32_t>::max();
      case 64:
        return std::numeric_limits<uint64_t>::max();
      // narrower types do not trigger the trap
      // wider types are not supported
      default:
        llvm_unreachable("unexpected type");
      }
    }
  }
  return 0;
}

uint64_t UBSanTrapWarnFilter::evalAllConstantsArithExpr(const Expr *E,
                                                        ASTContext &Context,
                                                        bool &Valid) {
  uint64_t Val;
  if (const IntegerLiteral *IL = dyn_cast<const IntegerLiteral>(E)) {
    Val = IL->getValue().getZExtValue();
  } else if (const ImplicitCastExpr *ICE =
                 dyn_cast<const ImplicitCastExpr>(E)) {
    Val = evalAllConstantsArithExpr(ICE->getSubExpr(), Context, Valid);
  } else if (const ParenExpr *PE = dyn_cast<const ParenExpr>(E)) {
    Val = evalAllConstantsArithExpr(PE->getSubExpr()->IgnoreParenCasts(),
                                    Context, Valid);
  } else if (const BinaryOperator *BO = dyn_cast<const BinaryOperator>(E)) {
    uint64_t LHS = evalAllConstantsArithExpr(BO->getLHS(), Context, Valid);
    if (!Valid)
      return 0;
    uint64_t RHS = evalAllConstantsArithExpr(BO->getRHS(), Context, Valid);
    if (!Valid)
      return 0;
    switch (BO->getOpcode()) {
    case BO_Add:
      Val = LHS + RHS;
      break;
    case BO_Mul:
      Val = LHS * RHS;
      break;
    default:
      Valid = false;
      return 0;
    }
  } else {
    Valid = false;
    return 0;
  }
  uint64_t TypeMax = getExprTypeMax(E, Context);
  if (!TypeMax)
    Valid = false;
  return TypeMax & Val;
}

// OverflowLoc is a MetaData, containing the source location
// of a possibly overflowing expression.
// OverflowLoc is used by the triggered ubsantrap_unique instrinsic
// and about to be used for emitting a warning for that trap.
// To eliminate the warning, this function replaces the ubsantrap_unique
// with a regular ubsantrap, and discards OverflowLoc
void UBSanTrapWarnFilter::eliminateWarning(Value *OverflowLoc) {
  for (llvm::User *U : OverflowLoc->users()) {
    if (llvm::IntrinsicInst *Intr = dyn_cast<llvm::IntrinsicInst>(U)) {
      if (Intr->getIntrinsicID() == llvm::Intrinsic::ubsantrap_unique) {
        llvm::Function *Fn = Intr->getParent()->getParent();
        if (TrapWarningTrace) {
          llvm::errs() << "Found guarding precondition for overflow trap: "
                       << Fn->getName() << " : " << *Intr << "\n";
        }
        llvm::Module *M = Fn->getParent();
        llvm::Function *IntrinsicFunc =
            llvm::Intrinsic::getDeclaration(M, llvm::Intrinsic::ubsantrap);
        Value *TrapOp = Intr->getOperand(0);
        llvm::CallInst *NewCall =
            llvm::CallInst::Create(IntrinsicFunc, {TrapOp}, "", Intr);
        Intr->replaceAllUsesWith(NewCall);
        Intr->eraseFromParent();
      }
    }
  }
}

void UBSanTrapWarnFilter::removeWarningFromList(const Expr *GuardedExpr) {
  OverflowIter I;
  if (!CGM->OverflowExpr.empty()) {
    for (I = CGM->OverflowExpr.begin(); I != CGM->OverflowExpr.end(); I++) {
      const Expr *E = I->first;
      if (E == GuardedExpr) {
        eliminateWarning(I->second);
        break;
      }
    }
    if (I != CGM->OverflowExpr.end())
      CGM->OverflowExpr.erase(I);
  }
}

bool UBSanTrapWarnFilter::isBoundMax(const MatchFinder::MatchResult &Result) {
  uint64_t BoundVal, TypeMax;
  if (const IntegerLiteral *BoundLit =
          Result.Nodes.getNodeAs<IntegerLiteral>("bound")) {
    BoundVal = BoundLit->getValue().getZExtValue();
    TypeMax = getExprTypeMax(BoundLit, *Result.Context);
  } else if (const Expr *BoundExpr = Result.Nodes.getNodeAs<Expr>("bound")) {
    bool Valid;
    BoundVal = evalAllConstantsArithExpr(BoundExpr, *Result.Context, Valid);
    if (!Valid)
      return false;
    TypeMax = getExprTypeMax(BoundExpr, *Result.Context);
  } else {
    return false;
  }
  return TypeMax == BoundVal;
}

//===----------------------------------------------------------------------===//
// pattern matching: final step
//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
// structure of precondition and guarded unary operation matches,
// now check if variable matches
//===----------------------------------------------------------------------===//
class UnaryOpCallback : public UBSanTrapWarnFilter {
public:
  UnaryOpCallback(CodeGenModule *CGM, const DeclRefExpr *precondVar)
      : UBSanTrapWarnFilter(CGM), PrecondVar(precondVar) {}
  void run(const MatchFinder::MatchResult &Result) override {
    if (const DeclRefExpr *Operand =
            Result.Nodes.getNodeAs<DeclRefExpr>("operand")) {
      if (Operand->getDecl() == PrecondVar->getDecl()) {
        const Expr *Overflow = Result.Nodes.getNodeAs<Expr>("Overflow");
        removeWarningFromList(Overflow);
      }
    }
  }

private:
  const DeclRefExpr *PrecondVar;
};

//===----------------------------------------------------------------------===//
// structure of precondition and guarded binary operation matches,
// now check if variables match
//===----------------------------------------------------------------------===//
class BinOpCallback : public UBSanTrapWarnFilter {
public:
  BinOpCallback(CodeGenModule *CGM, const DeclRefExpr *condLHS,
                const DeclRefExpr *condRHS)
      : UBSanTrapWarnFilter(CGM), CondLHS(condLHS), CondRHS(condRHS) {}
  void run(const MatchFinder::MatchResult &Result) override {
    if (const DeclRefExpr *LHS = Result.Nodes.getNodeAs<DeclRefExpr>("LHS")) {
      if (const DeclRefExpr *RHS = Result.Nodes.getNodeAs<DeclRefExpr>("RHS")) {
        if (LHS->getDecl() == CondLHS->getDecl() &&
            RHS->getDecl() == CondRHS->getDecl()) {
          const Expr *Overflow = Result.Nodes.getNodeAs<Expr>("Overflow");
          removeWarningFromList(Overflow);
        }
      }
    }
  }

private:
  const DeclRefExpr *CondLHS, *CondRHS;
};

//===----------------------------------------------------------------------===//
// found a match to an expression usually written in a precondition,
// redundantly creates a trap: 'max - a'  (e.g. in 'max - a < b')
// this pattern does not require multiple steps to be recognized
//===----------------------------------------------------------------------===//
class MaxSubCallback : public UBSanTrapWarnFilter {
public:
  MaxSubCallback(CodeGenModule *CGM) : UBSanTrapWarnFilter(CGM) {}
  void run(const MatchFinder::MatchResult &Result) override {
    if (isBoundMax(Result))
      if (const Expr *Sub = Result.Nodes.getNodeAs<Expr>("sub"))
        removeWarningFromList(Sub);
  }
};

//===----------------------------------------------------------------------===//
// pattern matching: forth step
//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
// found a potentially guarding precondition, check if guarded statement is
// matching
// -----------+-------------
// expression | precondition
// -----------+-------------
//  a--       | a == 0
//  --a       |
//===----------------------------------------------------------------------===//
class EqZeroCallback : public UBSanTrapWarnFilter {
public:
  EqZeroCallback(CodeGenModule *CGM, const Stmt *Guarded)
      : UBSanTrapWarnFilter(CGM), GuardedStmt(Guarded) {}
  void run(const MatchFinder::MatchResult &Result) override {
    if (const DeclRefExpr *LHS = Result.Nodes.getNodeAs<DeclRefExpr>("LHS")) {
      MatchFinder Finder;
      UnaryOpCallback Callback(CGM, LHS);
      auto decrMatcherBase = unaryOperator(hasOperatorName("--"),
                                           has(declRefExpr().bind("operand")))
                                 .bind("Overflow");
      Finder.addMatcher(decrMatcherBase, &Callback);
      auto decrMatcherWrap = stmt(hasDescendant(decrMatcherBase));
      Finder.addMatcher(decrMatcherWrap, &Callback);
      Finder.match(*GuardedStmt, *Result.Context);
    }
  }

private:
  const Stmt *GuardedStmt;
};

//===----------------------------------------------------------------------===//
// found a potentially guarding precondition, check if guarded statement is
// matching
// -----------+-------------
// expression | precondition
// -----------+-------------
//  a++       | a == max
//  ++a       |
//===----------------------------------------------------------------------===//
class EqMaxCallback : public UBSanTrapWarnFilter {
public:
  EqMaxCallback(CodeGenModule *CGM, const Stmt *Guarded)
      : UBSanTrapWarnFilter(CGM), GuardedStmt(Guarded) {}
  void run(const MatchFinder::MatchResult &Result) override {
    if (const DeclRefExpr *LHS = Result.Nodes.getNodeAs<DeclRefExpr>("LHS")) {
      if (isBoundMax(Result)) {
        MatchFinder Finder;
        UnaryOpCallback Callback(CGM, LHS);
        auto incrMatcherBase = unaryOperator(hasOperatorName("++"),
                                             has(declRefExpr().bind("operand")))
                                   .bind("Overflow");
        Finder.addMatcher(incrMatcherBase, &Callback);
        auto incrMatcherWrap = stmt(hasDescendant(incrMatcherBase));
        Finder.addMatcher(incrMatcherWrap, &Callback);
        Finder.match(*GuardedStmt, *Result.Context);
      }
    }
  }

private:
  const Stmt *GuardedStmt;
};

//===----------------------------------------------------------------------===//
// found a potentially guarding precondition, check if guarded statement is
// matching
// -----------+-------------
// expression | precondition
// -----------+-------------
//  a + b     | max - a < b
//  a += b    |
//===----------------------------------------------------------------------===//
class MaxSubLowerThanCallback : public UBSanTrapWarnFilter {
public:
  MaxSubLowerThanCallback(CodeGenModule *CGM, const Stmt *Guarded)
      : UBSanTrapWarnFilter(CGM), GuardedStmt(Guarded) {}
  void run(const MatchFinder::MatchResult &Result) override {
    const DeclRefExpr *LHS = Result.Nodes.getNodeAs<DeclRefExpr>("LHS");
    const DeclRefExpr *RHS = Result.Nodes.getNodeAs<DeclRefExpr>("RHS");
    if (!LHS || !RHS)
      return;
    if (isBoundMax(Result)) {
      MatchFinder Finder;
      BinOpCallback Callback(CGM, LHS, RHS);
      auto createAddMatcher = [](bool IsCompoundAssign) {
        return binaryOperator(
                   hasOperatorName(IsCompoundAssign ? "+=" : "+"),
                   hasLHS(IsCompoundAssign ? declRefExpr().bind("LHS")
                                           : implicitCastExpr(has(
                                                 declRefExpr().bind("LHS")))),
                   hasRHS(implicitCastExpr(has(declRefExpr().bind("RHS")))))
            .bind("Overflow");
      };
      auto addMatcher = createAddMatcher(false);
      auto addMatcherWrap = stmt(hasDescendant(addMatcher));
      auto addAssignMatcher = createAddMatcher(true);
      auto addAssignMatcherWrap = stmt(hasDescendant(addAssignMatcher));
      Finder.addMatcher(addMatcher, &Callback);
      Finder.addMatcher(addMatcherWrap, &Callback);
      Finder.addMatcher(addAssignMatcher, &Callback);
      Finder.addMatcher(addAssignMatcherWrap, &Callback);
      Finder.match(*GuardedStmt, *Result.Context);
    }
  }

private:
  const Stmt *GuardedStmt;
};

//===----------------------------------------------------------------------===//
// found a potentially guarding precondition, check if guarded statement is
// matching
// -----------+-------------
// expression | precondition
// -----------+-------------
//  a * b     | a && max/a < b
//  a *= b    |
//===----------------------------------------------------------------------===//
class AndMaxDivideLowerThanCallback : public UBSanTrapWarnFilter {
public:
  AndMaxDivideLowerThanCallback(CodeGenModule *CGM, const Stmt *Guarded)
      : UBSanTrapWarnFilter(CGM), GuardedStmt(Guarded) {}
  void run(const MatchFinder::MatchResult &Result) override {
    const DeclRefExpr *LHS = Result.Nodes.getNodeAs<DeclRefExpr>("LHS1");
    const DeclRefExpr *LHS2 = Result.Nodes.getNodeAs<DeclRefExpr>("LHS2");
    const DeclRefExpr *RHS = Result.Nodes.getNodeAs<DeclRefExpr>("RHS");
    if (!LHS || !LHS2 || !RHS)
      return;
    if (LHS->getDecl() != LHS2->getDecl())
      return;
    if (isBoundMax(Result)) {
      MatchFinder Finder;
      BinOpCallback Callback(CGM, LHS, RHS);
      auto createMulMatcher = [](bool IsCompoundAssign) {
        return binaryOperator(
                   hasOperatorName(IsCompoundAssign ? "*=" : "*"),
                   hasLHS(IsCompoundAssign ? declRefExpr().bind("LHS")
                                           : implicitCastExpr(has(
                                                 declRefExpr().bind("LHS")))),
                   hasRHS(implicitCastExpr(has(declRefExpr().bind("RHS")))))
            .bind("Overflow");
      };
      auto mulMatcher = createMulMatcher(false);
      auto mulMatcherWrap = stmt(hasDescendant(mulMatcher));
      auto mulAssignMatcher = createMulMatcher(true);
      auto mulAssignMatcherWrap = stmt(hasDescendant(mulAssignMatcher));
      Finder.addMatcher(mulMatcher, &Callback);
      Finder.addMatcher(mulMatcherWrap, &Callback);
      Finder.addMatcher(mulAssignMatcher, &Callback);
      Finder.addMatcher(mulAssignMatcherWrap, &Callback);
      Finder.match(*GuardedStmt, *Result.Context);
    }
  }

private:
  const Stmt *GuardedStmt;
};

//===----------------------------------------------------------------------===//
// found a potentially guarding precondition, check if guarded statement is
// matching
// -----------+-------------
// expression | precondition
// -----------+-------------
//  a - b     | a < b
//  a -= b    |
//===----------------------------------------------------------------------===//
class LowerThanCallback : public UBSanTrapWarnFilter {
public:
  LowerThanCallback(CodeGenModule *CGM, const Stmt *Guarded)
      : UBSanTrapWarnFilter(CGM), GuardedStmt(Guarded) {}
  void run(const MatchFinder::MatchResult &Result) override {
    if (const DeclRefExpr *LHS = Result.Nodes.getNodeAs<DeclRefExpr>("LHS")) {
      if (const DeclRefExpr *RHS = Result.Nodes.getNodeAs<DeclRefExpr>("RHS")) {
        MatchFinder Finder;
        BinOpCallback Callback(CGM, LHS, RHS);
        auto createSubMatcher = [](bool IsCompoundAssign) {
          return binaryOperator(
                     hasOperatorName(IsCompoundAssign ? "-=" : "-"),
                     hasLHS(IsCompoundAssign ? declRefExpr().bind("LHS")
                                             : implicitCastExpr(has(
                                                   declRefExpr().bind("LHS")))),
                     hasRHS(implicitCastExpr(has(declRefExpr().bind("RHS")))))
              .bind("Overflow");
        };
        auto subMatcher = createSubMatcher(false);
        auto subMatcherWrap = stmt(hasDescendant(subMatcher));
        auto subAssignMatcher = createSubMatcher(true);
        auto subAssignMatcherWrap = stmt(hasDescendant(subAssignMatcher));
        Finder.addMatcher(subMatcher, &Callback);
        Finder.addMatcher(subMatcherWrap, &Callback);
        Finder.addMatcher(subAssignMatcher, &Callback);
        Finder.addMatcher(subAssignMatcherWrap, &Callback);
        Finder.match(*GuardedStmt, *Result.Context);
      }
    }
  }

private:
  const Stmt *GuardedStmt;
};

//===----------------------------------------------------------------------===//
// pattern matching: third step
//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
// pattern matching of potential preconditions, upon a match,
// a callback with a matcher to the corresponding
// guarded overflowing expression
// is being called
//===----------------------------------------------------------------------===//
void UBSanTrapWarnFilter::matchCondition(
    const Expr *Cond, const Stmt *GuardedStmt,
    const MatchFinder::MatchResult &Result) {
  if (TrapWarningTrace > 1) {
    llvm::errs() << "Inspecting precondition\n";
    Cond->dump();
    llvm::errs() << "Potentially guarding statement\n";
    GuardedStmt->dump();
  }
  // a list of potential guarding patterns
  // if there is a match, the callback will look for a match
  // between the guarding condition and the guarded statement
  std::vector<std::function<void(const Expr *, const Stmt *,
                                 const MatchFinder::MatchResult)>>
      lambdaFilters = {
          // expression | precondition
          // -----------+-------------
          //  a--       | a == 0
          //  --a       |
          [this](const Expr *Cond, const Stmt *GuardedStmt,
                 const MatchFinder::MatchResult &Result) {
            MatchFinder Finder;
            EqZeroCallback Callback(CGM, GuardedStmt);
            auto eqZero = binaryOperator(
                hasOperatorName("=="),
                hasLHS(implicitCastExpr(has(declRefExpr().bind("LHS")))),
                hasRHS(implicitCastExpr(has(integerLiteral(equals(0))))));
            Finder.addMatcher(eqZero, &Callback);
            Finder.match(*Cond, *Result.Context);
          },
          //  a++       | a == max
          //  ++a       |
          [this](const Expr *Cond, const Stmt *GuardedStmt,
                 const MatchFinder::MatchResult &Result) {
            MatchFinder Finder;
            EqMaxCallback Callback(CGM, GuardedStmt);
            auto createMatcher = [](bool IsLiteral) {
              return binaryOperator(
                  hasOperatorName("=="),
                  hasLHS(implicitCastExpr(has(declRefExpr().bind("LHS")))),
                  hasRHS(IsLiteral ? integerLiteral().bind("bound")
                                   : parenExpr(has(expr().bind("bound")))));
            };
            auto eqMaxLit = createMatcher(true);
            auto eqMaxExpr = createMatcher(false);
            Finder.addMatcher(eqMaxLit, &Callback);
            Finder.addMatcher(eqMaxExpr, &Callback);
            Finder.match(*Cond, *Result.Context);
          },
          //  a - b     | a < b
          //  a -= b    |
          [this](const Expr *Cond, const Stmt *GuardedStmt,
                 const MatchFinder::MatchResult &Result) {
            MatchFinder Finder;
            LowerThanCallback Callback(CGM, GuardedStmt);
            auto lowerThan = binaryOperator(
                hasOperatorName("<"),
                hasLHS(implicitCastExpr(has(declRefExpr().bind("LHS")))),
                hasRHS(implicitCastExpr(has(declRefExpr().bind("RHS")))));
            Finder.addMatcher(lowerThan, &Callback);
            Finder.match(*Cond, *Result.Context);
          },
          //  a + b     | max - a < b
          //  a += b    |
          [this](const Expr *Cond, const Stmt *GuardedStmt,
                 const MatchFinder::MatchResult &Result) {
            MatchFinder Finder;
            MaxSubLowerThanCallback Callback(CGM, GuardedStmt);
            auto createMatcher = [](bool IsLiteral) {
              return binaryOperator(
                  hasOperatorName("<"),
                  hasLHS(binaryOperator(
                      hasOperatorName("-"),
                      hasLHS(IsLiteral ? integerLiteral().bind("bound")
                                       : parenExpr(has(expr().bind("bound")))),
                      hasRHS(
                          implicitCastExpr(has(declRefExpr().bind("LHS")))))),
                  hasRHS(implicitCastExpr(has(declRefExpr().bind("RHS")))));
            };
            auto lowerThanBoundLit = createMatcher(true);
            auto lowerThanBoundExpr = createMatcher(false);
            Finder.addMatcher(lowerThanBoundLit, &Callback);
            Finder.addMatcher(lowerThanBoundExpr, &Callback);
            Finder.match(*Cond, *Result.Context);
          },
          //  a * b     | a && max/a < b
          //  a *= b    |
          [this](const Expr *Cond, const Stmt *GuardedStmt,
                 const MatchFinder::MatchResult &Result) {
            MatchFinder Finder;
            AndMaxDivideLowerThanCallback Callback(CGM, GuardedStmt);
            auto createMatcher = [](bool IsLiteral) {
              return binaryOperator(
                  hasOperatorName("&&"),
                  hasLHS(implicitCastExpr(has(declRefExpr().bind("LHS1")))),
                  hasRHS(binaryOperator(
                      hasOperatorName("<"),
                      hasLHS(parenExpr(has(binaryOperator(
                          hasOperatorName("/"),
                          hasLHS(IsLiteral
                                     ? integerLiteral().bind("bound")
                                     : parenExpr(has(expr().bind("bound")))),
                          hasRHS(implicitCastExpr(
                              has(declRefExpr().bind("LHS2")))))))),
                      hasRHS(
                          implicitCastExpr(has(declRefExpr().bind("RHS")))))));
            };
            auto lowerThanBoundLit = createMatcher(true);
            auto lowerThanBoundExpr = createMatcher(false);
            Finder.addMatcher(lowerThanBoundLit, &Callback);
            Finder.addMatcher(lowerThanBoundExpr, &Callback);
            Finder.match(*Cond, *Result.Context);
          }};

  for (auto &lambdaFilter : lambdaFilters) {
    lambdaFilter(Cond, GuardedStmt, Result);
    // quit if previous match has removed the remainder
    // of the unguarded overflow cases
    if (CGM->OverflowExpr.empty())
      return;
  }
}

//===----------------------------------------------------------------------===//
// pattern matching: second step
//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
// pattern matching of high level structure:
// find potential guarding precondition and guarded overflowing expression
//===----------------------------------------------------------------------===//
class IfElseCallback : public UBSanTrapWarnFilter {
public:
  IfElseCallback(CodeGenModule *CGM) : UBSanTrapWarnFilter(CGM) {}
  void run(const MatchFinder::MatchResult &Result) override {
    const Expr *Cond = Result.Nodes.getNodeAs<Expr>("condition");
    const Stmt *ElseStmt = Result.Nodes.getNodeAs<Stmt>("elseStmt");
    if (Cond && ElseStmt)
      matchCondition(Cond, ElseStmt, Result);
  }
};

class IfGotoCallback : public UBSanTrapWarnFilter {
public:
  IfGotoCallback(CodeGenModule *CGM, const Stmt *Next)
      : UBSanTrapWarnFilter(CGM), NextStmt(Next) {}
  void run(const MatchFinder::MatchResult &Result) override {
    if (const Expr *Cond = Result.Nodes.getNodeAs<Expr>("condition"))
      matchCondition(Cond, NextStmt, Result);
  }

private:
  const Stmt *NextStmt;
};
class CompoundIfCallback : public UBSanTrapWarnFilter {
public:
  CompoundIfCallback(CodeGenModule *CGM) : UBSanTrapWarnFilter(CGM) {}
  void run(const MatchFinder::MatchResult &Result) override {
    if (const CompoundStmt *CS =
            Result.Nodes.getNodeAs<CompoundStmt>("compoundStmt")) {
      if (TrapWarningTrace > 1) {
        llvm::errs() << "CompoundIfCallback triggered by\n";
        CS->dump();
      }
      for (auto it = CS->body_begin(); it != CS->body_end(); ++it) {
        auto nextIt = std::next(it);
        if (IfStmt *IS = dyn_cast<IfStmt>(*it)) {
          // if (precondition) {...} else may-overflow expression;
          MatchFinder Finder1, Finder2;
          IfElseCallback ElseCallback(CGM);
          auto ifWithElseExprMatcher =
              ifStmt(hasCondition(expr().bind("condition")),
                     hasElse(stmt().bind("elseStmt")));
          Finder1.addMatcher(ifWithElseExprMatcher, &ElseCallback);
          Finder1.match(*IS, *Result.Context);
          if (nextIt != CS->body_end()) {
            // if (precondition) {... goto err;} may-overflow expression;
            const Stmt *NextStmt = *nextIt;
            IfGotoCallback GotoCallback(CGM, NextStmt);
            auto ifStmtGotoMatcher = ifStmt(
                hasCondition(expr().bind("condition")), hasThen(gotoStmt()));
            auto ifStmtWithGotoMatcher =
                ifStmt(hasCondition(expr().bind("condition")),
                       hasThen(compoundStmt(has(gotoStmt()))));
            Finder2.addMatcher(ifStmtGotoMatcher, &GotoCallback);
            Finder2.addMatcher(ifStmtWithGotoMatcher, &GotoCallback);
            Finder2.match(*IS, *Result.Context);
          }
        }
      }
    }
  }
};

//===----------------------------------------------------------------------===//
// pattern matching: first step
//===----------------------------------------------------------------------===//
static void findGuardedOverflowExpr(CodeGenModule *CGM) {
  {
    // main search: if (precondition) {... goto err;} may-overflow expression;
    //            : if (precondition) {...} else may-overflow expression;
    MatchFinder Finder;
    CompoundIfCallback Callback(CGM);
    auto compoundStmtMatcher = compoundStmt(has(ifStmt())).bind("compoundStmt");
    Finder.addMatcher(compoundStmtMatcher, &Callback);
    Finder.matchAST(CGM->getContext());
  }
  {
    // by-product of adding a precondition: the expression 'MAX - variable
    // appears in preconditions and unnecessarily generates trap code
    MatchFinder Finder;
    MaxSubCallback Callback(CGM);
    auto createMatcher = [](bool IsLiteral) {
      return binaryOperator(
                 hasOperatorName("-"),
                 hasLHS(IsLiteral ? integerLiteral().bind("bound")
                                  : parenExpr(has(expr().bind("bound")))),
                 hasRHS(implicitCastExpr(has(
                     declRefExpr(to(varDecl(hasType(isUnsignedInteger()))))))))
          .bind("sub");
    };
    auto maxSubLitMatcher = createMatcher(true);
    auto maxSubExprMatcher = createMatcher(false);
    Finder.addMatcher(maxSubLitMatcher, &Callback);
    Finder.addMatcher(maxSubExprMatcher, &Callback);
    Finder.matchAST(CGM->getContext());
  }
}
} // namespace

//===----------------------------------------------------------------------===//
// entry point
//===----------------------------------------------------------------------===//
void CodeGenModule::filterGuardedUBSanTraps() {
  if (OverflowExpr.empty())
    return;

  findGuardedOverflowExpr(this);

  // cleanup
  if (!OverflowExpr.empty()) {
    unsigned DiagID;
    if (TrapWarningEmitInFE)
      DiagID = getDiags().getCustomDiagID(DiagnosticsEngine::Warning,
                                          "Unguarded overflow");
    for (auto I = OverflowExpr.begin(); I != OverflowExpr.end(); I++) {
      if (TrapWarningEmitInFE) {
        const Expr *E = I->first;
        SourceLocation Loc = E->getExprLoc();
        getDiags().Report(Loc, DiagID);
      }
    }
    OverflowExpr.clear();
  }
}
